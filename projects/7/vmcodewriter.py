

class VMCodeWriter:
    def __init__(self, out_file: str) -> None:
        self.out_file = out_file
        with open(self.out_file, 'w', encoding='utf-8') as f_out:
            f_out.write('// Generated by VM Code Writer written by Silas Kraume\n\n')
        self.label_id = 0

    def writeArithmetic(self, command: str) -> None:
        """
        Write the assembly code for the arithmetic command.
        """
        if command not in ['add', 'sub', 'neg', 'eq', 'gt', 'lt', 'and', 'or', 'not']:
            raise SyntaxError(f"Unknown arithmetic command: {command}")

        f_out = open(self.out_file, 'a', encoding='utf-8')
        def write(line: str) -> None:
            f_out.write(f"{line}\n")
        write(f"// {command}")

        if command not in ['neg', 'not']:
            write('@SP')
            write('AM=M-1')
            write('D=M')
            write('A=A-1')
        if command == 'add':
            write('M=D+M')
        if command in ['sub', 'eq', 'gt', 'lt']:
            write('M=M-D')
        if command == 'and':
            write('M=D&M')
        if command == 'or':
            write('M=D|M')

        if command in ['neg', 'not']:
            write('@SP')
            write('A=M-1')
        if command == 'neg':
            write('M=-M')
        if command == 'not':
            write('M=!M')

        if command in ['eq', 'gt', 'lt']:
            label_compare = f"COMPARISON{self.label_id}"
            label_compare_end = f"ENDCOMPARISON{self.label_id}"
            self.label_id += 1
            write('D=M')

            write(f"@{label_compare}")
            if command == 'eq':
                write('D;JEQ')
            if command == 'gt':
                write('D;JGT')
            if command == 'lt':
                write('D;JLT')

            write('@SP')
            write('A=M-1')
            write('M=0')
            write(f"@{label_compare_end}")
            write('0;JMP')

            write(f"({label_compare})")
            write('@SP')
            write('A=M-1')
            write('M=-1')

            write(f"({label_compare_end})")

        f_out.close()


    def writePushPop(self, command: str, segment: str, index: int) -> None:
        """
        Write the assembly code for the push/pop command.
        """
        if command not in ['C_PUSH', 'C_POP']:
            raise SyntaxError(f"Unknown command type for push/pop: {command}")

        f_out = open(self.out_file, 'a', encoding='utf-8')
        def write(line: str) -> None:
            f_out.write(f"{line}\n")
        write(f"// {command} {segment} {index}")

        if command == 'C_PUSH':
            if segment not in [
                'constant',
                'local', 'argument', 'this', 'that', 'static', 'temp', 'pointer'
            ]:
                raise SyntaxError(f"Unknown segment for push: {segment}")

            if segment == 'static':
                write(f"@{index + 16}")
            elif segment == 'temp':
                write(f"@{index + 5}")
            elif segment == 'pointer':
                write(f"@{index + 3}")
            else:
                write(f"@{index}")
            if segment not in ['static', 'temp', 'pointer']:
                write('D=A')

            if segment == 'local':
                write('@LCL')
            if segment == 'argument':
                write('@ARG')
            if segment == 'this':
                write('@THIS')
            if segment == 'that':
                write('@THAT')
            if segment in ['local', 'argument', 'this', 'that']:
                write('A=D+M')
            if segment != 'constant':
                write('D=M')

            write('@SP')
            write('A=M')
            write('M=D')
            write('@SP')
            write('M=M+1')

        if command == 'C_POP':
            if segment not in [
                'local', 'argument', 'this', 'that', 'static', 'temp', 'pointer'
            ]:
                raise SyntaxError(f"Unknown segment for push: {segment}")

            if segment == 'static':
                write(f"@{index + 16}")
            elif segment == 'temp':
                write(f"@{index + 5}")
            elif segment == 'pointer':
                write(f"@{index + 3}")
            else:
                write(f"@{index}")

            write('D=A')

            if segment not in ['static', 'temp', 'pointer']:
                if segment == 'local':
                    write('@LCL')
                if segment == 'argument':
                    write('@ARG')
                if segment == 'this':
                    write('@THIS')
                if segment == 'that':
                    write('@THAT')
                write('D=D+M')

            write('@R13')
            write('M=D')
            write('@SP')
            write('AM=M-1')
            write('D=M')
            write('@R13')
            write('A=M')
            write('M=D')

        f_out.close()
