
class VMCodeWriter:
    def __init__(self, out_file: str) -> None:
        self.out_file = out_file
        self.f_out = open(self.out_file, 'w', encoding='utf-8')
        self.writeAssembly('// Generated by VM Code Writer written by Silas Kraume\n\n')

        self.label_id = 0
        self.c_file = ''
        self.c_line = -1

    def writeAssembly(self, line: str) -> None:
        if not (line.startswith('//') or line.startswith('(')):
            self.f_out.write('    ')
        self.f_out.write(f"{line}\n")

    def setCurrentFileName(self, file_name: str) -> None:
        file_name = file_name.replace('\\', '_').replace('/', '_')
        self.c_file = ''.join(filter(lambda x: x.isalnum() or x in '_-.', file_name))

    def setCurrentLine(self, line: int) -> None:
        self.c_line = line

    def __del__(self):
        if hasattr(self, 'f_out') and not self.f_out.closed:
            self.f_out.close()


    def writeInit(self) -> None:
        """
        Write the bootstrap assembly code to initialize the VM.
        """
        self.writeAssembly('// init')
        self.writeAssembly('@256')
        self.writeAssembly('D=A')
        self.writeAssembly('@SP')
        self.writeAssembly('M=D\n')
        self.writeCall('Sys.init', 0)

    def writeArithmetic(self, command: str, *_) -> None:
        """
        Write the assembly code for the arithmetic command.
        """
        self.writeAssembly(f"// {command}")

        if command not in ['neg', 'not']:
            self.writeAssembly('@SP')
            self.writeAssembly('AM=M-1')
            self.writeAssembly('D=M')
            self.writeAssembly('A=A-1')
        if command == 'add':
            self.writeAssembly('M=D+M')
        if command in ['sub', 'eq', 'gt', 'lt']:
            self.writeAssembly('M=M-D')
        if command == 'and':
            self.writeAssembly('M=D&M')
        if command == 'or':
            self.writeAssembly('M=D|M')

        if command in ['neg', 'not']:
            self.writeAssembly('@SP')
            self.writeAssembly('A=M-1')
        if command == 'neg':
            self.writeAssembly('M=-M')
        if command == 'not':
            self.writeAssembly('M=!M')

        if command in ['eq', 'gt', 'lt']:
            label_compare = f"COMPARISON{self.label_id}"
            label_compare_end = f"ENDCOMPARISON{self.label_id}"
            self.label_id += 1
            self.writeAssembly('D=M')

            self.writeAssembly(f"@{label_compare}")
            if command == 'eq':
                self.writeAssembly('D;JEQ')
            if command == 'gt':
                self.writeAssembly('D;JGT')
            if command == 'lt':
                self.writeAssembly('D;JLT')

            self.writeAssembly('@SP')
            self.writeAssembly('A=M-1')
            self.writeAssembly('M=0')
            self.writeAssembly(f"@{label_compare_end}")
            self.writeAssembly('0;JMP')

            self.writeAssembly(f"({label_compare})")
            self.writeAssembly('@SP')
            self.writeAssembly('A=M-1')
            self.writeAssembly('M=-1')

            self.writeAssembly(f"({label_compare_end})")

        self.writeAssembly('')

    def writePush(self, segment: str, index: int, *_) -> None:
        """
        Write the assembly code for the push command.
        """
        if segment not in [
            'constant',
            'local', 'argument', 'this', 'that', 'static', 'temp', 'pointer'
        ]:
            raise SyntaxError(f"Unknown segment for push: '{segment}' at line {self.c_line}")

        self.writeAssembly(f"// push {segment} {index}")
        if segment == 'static':
            self.writeAssembly(f"@{self.c_file}.{index}")
        elif segment == 'temp':
            self.writeAssembly(f"@{index + 5}")
        else:
            self.writeAssembly(f"@{index}")
        if segment not in ['static', 'temp']:
            self.writeAssembly('D=A')

        if segment == 'local':
            self.writeAssembly('@LCL')
        if segment == 'argument':
            self.writeAssembly('@ARG')
        if segment in ['this', 'pointer']:
            self.writeAssembly('@THIS')
        if segment == 'that':
            self.writeAssembly('@THAT')
        if segment in ['local', 'argument', 'this', 'that']:
            self.writeAssembly('A=D+M')
        if segment == 'pointer':
            self.writeAssembly('A=D+A')
        if segment != 'constant':
            self.writeAssembly('D=M')

        self.writeAssembly('@SP')
        self.writeAssembly('A=M')
        self.writeAssembly('M=D')
        self.writeAssembly('@SP')
        self.writeAssembly('M=M+1\n')

    def writePop(self, segment: str, index: int, *_) -> None:
        """
        Write the assembly code for the pop command.
        """
        if segment not in [
            'local', 'argument', 'this', 'that', 'static', 'temp', 'pointer'
        ]:
            raise SyntaxError(f"Unknown segment for push: '{segment}' at line {self.c_line}")

        self.writeAssembly(f"// pop {segment} {index}")
        if segment == 'static':
            self.writeAssembly(f"@{self.c_file}.{index}")
        elif segment == 'temp':
            self.writeAssembly(f"@{index + 5}")
        else:
            self.writeAssembly(f"@{index}")

        self.writeAssembly('D=A')

        if segment == 'local':
            self.writeAssembly('@LCL')
        if segment == 'argument':
            self.writeAssembly('@ARG')
        if segment in ['this', 'pointer']:
            self.writeAssembly('@THIS')
        if segment == 'that':
            self.writeAssembly('@THAT')
        if segment not in ['static', 'temp', 'pointer']:
            self.writeAssembly('D=D+M')
        if segment == 'pointer':
            self.writeAssembly('D=D+A')

        self.writeAssembly('@R13')
        self.writeAssembly('M=D')
        self.writeAssembly('@SP')
        self.writeAssembly('AM=M-1')
        self.writeAssembly('D=M')
        self.writeAssembly('@R13')
        self.writeAssembly('A=M')
        self.writeAssembly('M=D\n')

    def writeLabel(self, label: str, *_) -> None:
        self.writeAssembly(f"// label {label}")
        self.writeAssembly(f"({label})\n")

    def writeGoto(self, label: str, *_) -> None:
        self.writeAssembly(f"// goto {label}")
        self.writeAssembly(f"@{label}")
        self.writeAssembly('0;JMP\n')

    def writeIf(self, label: str, *_) -> None:
        self.writeAssembly(f"// if-goto {label}")
        self.writeAssembly('@SP')
        self.writeAssembly('AM=M-1')
        self.writeAssembly('D=M')
        self.writeAssembly(f"@{label}")
        self.writeAssembly('D;JNE\n')

    def writeFunction(self, functionName: str, numLocals: int, *_) -> None:
        self.writeAssembly(f"// function {functionName} {numLocals}")
        self.writeAssembly(f"({functionName})")

        for i in range(numLocals):
            self.writeAssembly(f"@SP // Initialize local variable {i}")
            self.writeAssembly('A=M')
            self.writeAssembly('M=0')
            self.writeAssembly('@SP')
            self.writeAssembly('M=M+1\n')

    def writeCall(self, functionName: str, numArgs: int, *_) -> None:
        self.writeAssembly(f"// call {functionName} {numArgs}")

        return_label = f"RETURN_{functionName}_{self.label_id}"
        self.label_id += 1
        self.writeAssembly(f"@{return_label} // save return address")
        self.writeAssembly('D=A')
        self.writeAssembly('@SP')
        self.writeAssembly('A=M')
        self.writeAssembly('M=D')
        self.writeAssembly('@SP')
        self.writeAssembly('M=M+1\n')

        for segment in ['LCL', 'ARG', 'THIS', 'THAT']:
            self.writeAssembly(f"@{segment} // save @{segment} segment")
            self.writeAssembly('D=M')
            self.writeAssembly('@SP')
            self.writeAssembly('A=M')
            self.writeAssembly('M=D')
            self.writeAssembly('@SP')
            self.writeAssembly('M=M+1\n')

        self.writeAssembly(f"@{numArgs + 5} // reposition ARG to SP - numArgs - 5")
        self.writeAssembly('D=A')
        self.writeAssembly('@SP')
        self.writeAssembly('D=M-D')
        self.writeAssembly('@ARG')
        self.writeAssembly('M=D\n')

        self.writeAssembly('@SP // reposition LCL to SP')
        self.writeAssembly('D=M')
        self.writeAssembly('@LCL')
        self.writeAssembly('M=D\n')

        self.writeAssembly(f"@{functionName} // transfer control to function")
        self.writeAssembly('0;JMP')
        self.writeAssembly(f"({return_label})\n")

    def writeReturn(self, *_) -> None:
        self.writeAssembly('// return')

        self.writeAssembly('@LCL // save LCL in R13')
        self.writeAssembly('D=M')
        self.writeAssembly('@R13')
        self.writeAssembly('M=D\n')

        self.writeAssembly('@5 // save return address in R14')
        self.writeAssembly('A=D-A')
        self.writeAssembly('D=M')
        self.writeAssembly('@R14')
        self.writeAssembly('M=D\n')

        self.writeAssembly('@SP // reposition return value for caller')
        self.writeAssembly('AM=M-1')
        self.writeAssembly('D=M')
        self.writeAssembly('@ARG')
        self.writeAssembly('A=M')
        self.writeAssembly('M=D\n')

        self.writeAssembly('@ARG // restore SP for caller')
        self.writeAssembly('D=M+1')
        self.writeAssembly('@SP')
        self.writeAssembly('M=D\n')

        for segment in ['THAT', 'THIS', 'ARG', 'LCL']:
            self.writeAssembly(f'@R13 // restore @{segment} segment')
            self.writeAssembly('AM=M-1')
            self.writeAssembly('D=M')
            self.writeAssembly(f'@{segment}')
            self.writeAssembly('M=D\n')

        self.writeAssembly('@R14 // return to caller')
        self.writeAssembly('A=M')
        self.writeAssembly('0;JMP\n')
